# VARIABLES
variable fname index InitialFile.txt
variable simname index InitialFile

# Initialization
units		lj
boundary	    p p p
atom_style	bond
read_restart	restart.equil 
#read_data InitialFile.txt extra/bond/per/atom 3 extra/special/per/atom 3

# Dreiding potential information
neighbor	2.0 bin
neigh_modify every 1 delay 0 check yes

# Define the bond potential
# Type - Energy - Equilibrium bond length
bond_style      harmonic
bond_coeff	Normal 30 1
bond_coeff	MM 30 1
special_bonds lj/coul 0.0 0.0 0.5

# Define morse potentials D - alpha - r0 
pair_style	morse 3.0 # Cutoff
pair_coeff	* * 5e-2 2 1.5
pair_coeff M M 5e-2 2 1.0

compute csym all centro/atom fcc
compute peratom all pe/atom

#####################################################
# set timestep of integrator

timestep 0.01

#####################################################
compute R2 all gyration 
compute pe all pe

#####################################################
# Equilibration (Brownian dynamics at 300 K)

# Not necessary anymore as it is already equilibrated

#velocity 	all create 1.0 12315
#fix		1 all nve/limit 0.5
#fix 2 all langevin 1.0 1.0 1.0 12315
#thermo_style	custom step temp 
#thermo          10000

#run		1000000

#write_restart restart.equil
# Not necessary anymore to have a restart file as it is already loaded

#####################################################
# Calculate volume of polymer
variable natoms equal count(all)   # Count total atoms
variable lx equal lx                # Current x dimension of simulation box
variable ly equal ly                # Current y dimension of simulation box
variable lz equal lz                # Current z dimension of simulation box
variable volume_polymer equal "v_lx*v_ly*v_lz/v_natoms"   # Volume of polymer

# Calculate new box dimensions
variable margin equal 10.0         # Margin to add to volume of polymer
variable new_volume equal "v_volume_polymer + v_margin"         # New volume of simulation box
variable scale_factor equal (v_new_volume/v_volume_polymer)^(1.0/3.0)
change_box all x scale ${scale_factor} y scale ${scale_factor} z scale ${scale_factor} boundary f p p

#####################################################

#unfix 1
#unfix 2

#fix 1 .0
#minimize 1.0e-4 1.0e-6 1000 10000

dump mydmp all atom 500 dump.lammpstrj

#####################################################
# CenH Region, Promoter and Transcription

group cenH id 61:90
group promoter id 120 121 122
group transc id 123:130
group others subtract all cenH promoter transc
group outOFCenH subtract all cenH
group M_Atoms type 3
group NotPromoter subtract all promoter
#####################################################

timestep 0.001

#####################################################
molecule AM_post AM_post-reaction.template
molecule AM_pre AM_pre-reaction.template
molecule AU_post AU_post-reaction.template
molecule AU_pre AU_pre-reaction.template
molecule MA_post MA_post-reaction.template
molecule MA_pre MA_pre-reaction.template
molecule MU_post MU_post-reaction.template
molecule MU_pre MU_pre-reaction.template



#####################################################
# Do the reactions
fix 4 all bond/react  &
    react reacAU NotPromoter 1 0 2 AM_pre AM_post simple.map molecule intra prob 1e-5 1390 &
    react reacMU NotPromoter 1 0 2 AU_pre AU_post simple.map molecule intra prob 1e-5 389 &
    react reacUA NotPromoter 1 0 2 MA_pre MA_post simple.map molecule intra prob 1e-5 3890 &
    react reacUM NotPromoter 1 0 2 MU_pre MU_post simple.map molecule intra prob 1e-5  2866 &
    react reacUMcenH cenH 1 0 2 MU_pre MU_post simple.map molecule intra prob 1e-4 3890 &
    react reacUAcenH cenH 1 0 2 MA_pre MA_post simple.map molecule intra prob 1e-4  2866 &



thermo_style custom step temp c_R2[0] c_pe[0] f_4[1] f_4[2] f_4[3] f_4[4]
thermo 10000

fix		1 all nve/limit 0.5

####################################################
# WALL CONDITIONS

fix mywall M_Atoms wall/lj93 xlo EDGE 10 10 100 xhi EDGE 10 10 100

####################################################

fix myfixR2 chromatin ave/time 10 100 1000 c_R2[0] file r2.dat
fix myfixpe all ave/time 10 100 1000 c_pe[0] file pe.dat
fix myfixReac all ave/time 10 100 1000 f_4[1] f_4[2] f_4[3] f_4[4] file reac.dat

# Compute the count of atom types
compute myTypes all count/type atom

# Define a variable to store the count of atom types
variable typeA equal c_myTypes[1] 
variable typeU equal c_myTypes[2]
variable typeM equal c_myTypes[3]

# Output the count of atom types to a file every 1000 steps
fix myfixTypes all print 1000 "${typeA},${typeU},${typeM}" file types1.dat screen no


# Define a custom dump command to dump atom IDs and types every 500 steps
#dump 1 all custom 500 types2.dat id type

####################################################
dump myDump all custom 1000 id_and_type.dat id type 
#####################################################



label loopreplication
    run 2000000
    #####################################################
    # Replication => change half of the atoms to U's

    # Define the total number of atoms in your system
    variable total_atoms equal 200

    # Calculate half of the atoms
    variable half_atoms equal ${total_atoms}/2

    # Loop through half of the atoms and randomly change their types to U
    label loopa
        # Generate a random atom index
        variable random_index equal floor(random(1,${total_atoms},27939))

        # Change the atom's type to U
        set atom ${random_index} type U
            
        # Decrease the counter for half_atoms
        variable half_atoms equal ${half_atoms}-1

        # If half_atoms counter is not zero, continue the loop
        if '${half_atoms} > 0' then &
            "jump SELF loopa" &
        else "jump SELF loopaend"

    label loopaend


    #####################################################

jump SELF loopreplication


#####################################################